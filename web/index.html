<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Journeyman Matrix</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: white;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5rem;
            background: linear-gradient(45deg, #fff, #a8d8ff);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            opacity: 0.9;
            font-size: 1.1rem;
        }
        
        .game-section {
            margin-bottom: 30px;
        }
        
        .teams-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .team-card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .team-card.satisfied {
            border-color: #4ade80;
            background: rgba(74, 222, 128, 0.2);
        }
        
        .team-name {
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .team-players {
            margin-top: 8px;
            font-size: 0.9rem;
            opacity: 0.8;
            min-height: 20px;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .player-input-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        input[type="text"] {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
        }
        
        input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255, 255, 255, 0.15);
        }
        
        .players-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .player-tag {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .remove-player {
            background: rgba(255, 0, 0, 0.6);
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        
        .stats {
            text-align: center;
            font-size: 1.2rem;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        
        .satisfied-count {
            color: #4ade80;
            font-weight: bold;
        }
        
        .victory-message {
            text-align: center;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            font-size: 1.3rem;
            font-weight: bold;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        .error-message {
            background: rgba(239, 68, 68, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
        }

        /* Disambiguation Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal {
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
        }

        .modal h3 {
            margin-bottom: 20px;
            color: #1e3c72;
            text-align: center;
        }

        .player-option {
            display: block;
            width: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            margin: 8px 0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            text-align: left;
        }

        .player-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .player-option-teams {
            font-size: 0.8rem;
            opacity: 0.9;
            margin-top: 4px;
        }

        .modal-close {
            background: #dc2626;
            margin-top: 15px;
        }

        .validation-info {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            color: #1e40af;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèí The Journeyman Matrix Game</h1>
        <p class="subtitle">Find the fewest players who collectively played for all 8 teams!</p>
        
        <div class="controls">
            <button onclick="generateNewGame()">Practice Mode</button>
            <button onclick="startDailyMode()">Daily Challenge</button>
            <button onclick="clearPlayers()">Clear Players</button>
            <button id="optimalSolutionBtn" onclick="showOptimalSolution()" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); display: none;">Show Optimal Solution</button>
        </div>
        
        <div class="stats">
            <span id="gameMode">Practice Mode</span> | 
            Teams Satisfied: <span class="satisfied-count" id="satisfiedCount">0</span>/8 | 
            Players Used: <span id="playerCount">0</span>
            <div id="rarityScore" style="display: none; margin-top: 5px; font-size: 0.9rem;">
                Rarity Score: <span id="rarityValue">0</span>
            </div>
        </div>
        
        <div id="victoryMessage" class="victory-message" style="display: none;"></div>
        
        <div class="game-section">
            <h2>Selected Teams:</h2>
            <div id="teamsGrid" class="teams-grid"></div>
        </div>
        
        <div class="player-input-section">
            <h3>Add Players:</h3>
            <div class="input-group">
                <input type="text" id="playerInput" placeholder="Enter player name..." onkeypress="handleKeyPress(event)">
                <button onclick="addPlayer()">Add Player</button>
            </div>
            <div id="errorMessage" class="error-message" style="display: none;"></div>
            <div id="validationInfo" class="validation-info" style="display: none;"></div>
            <div id="playersList" class="players-list"></div>
        </div>
    </div>

    <!-- Disambiguation Modal -->
    <div id="disambiguationModal" class="modal-overlay" style="display: none;">
        <div class="modal">
            <h3>Multiple players found</h3>
            <p>Please select which player you meant:</p>
            <div id="playerOptions"></div>
            <button class="player-option modal-close" onclick="closeDisambiguationModal()">Cancel</button>
        </div>
    </div>

    <script>
        // Team codes mapping for NHL API
        const teamCodes = {
            "Anaheim Ducks": "ANA",
            "Boston Bruins": "BOS", 
            "Buffalo Sabres": "BUF",
            "Calgary Flames": "CGY",
            "Carolina Hurricanes": "CAR",
            "Chicago Blackhawks": "CHI",
            "Colorado Avalanche": "COL",
            "Columbus Blue Jackets": "CBJ",
            "Dallas Stars": "DAL",
            "Detroit Red Wings": "DET",
            "Edmonton Oilers": "EDM",
            "Florida Panthers": "FLA",
            "Los Angeles Kings": "LAK",
            "Minnesota Wild": "MIN",
            "Montreal Canadiens": "MTL",
            "Nashville Predators": "NSH",
            "New Jersey Devils": "NJD",
            "New York Islanders": "NYI",
            "New York Rangers": "NYR",
            "Ottawa Senators": "OTT",
            "Philadelphia Flyers": "PHI",
            "Pittsburgh Penguins": "PIT",
            "San Jose Sharks": "SJS",
            "Seattle Kraken": "SEA",
            "St. Louis Blues": "STL",
            "Tampa Bay Lightning": "TBL",
            "Toronto Maple Leafs": "TOR",
            "Utah Hockey Club": "UTA",
            "Vancouver Canucks": "VAN",
            "Vegas Golden Knights": "VGK",
            "Washington Capitals": "WSH",
            "Winnipeg Jets": "WPG"
        };

        // This will store the complete player database once loaded
        let playerDatabase = {};
        let isLoadingData = false;

        // Helper function to get player name from either string or PlayerInfo object
        function getPlayerName(player) {
            if (typeof player === 'string') {
                return player;
            } else if (player && typeof player === 'object' && player.name) {
                return player.name;
            }
            return '';
        }

        // Helper function to get all player names from a team's player list
        function getTeamPlayerNames(teamPlayers) {
            if (!teamPlayers || !Array.isArray(teamPlayers)) {
                return [];
            }
            return teamPlayers.map(player => getPlayerName(player));
        }

        // Load comprehensive NHL player data from the API
        async function loadNHLPlayerData() {
            if (isLoadingData) return;
            isLoadingData = true;
            
            const loadingElement = document.createElement('div');
            loadingElement.id = 'loadingIndicator';
            loadingElement.className = 'stats';
            loadingElement.innerHTML = 'üèí Loading comprehensive NHL player database... This may take a moment.';
            document.querySelector('.container').insertBefore(loadingElement, document.querySelector('.game-section'));

            playerDatabase = {};

            const response = await fetch('https://journeyman.edgecompute.app/get_playersv2');
            if (response.ok) {
                playerDatabase = await response.json();
                // Convert Set back to Array 

                isLoadingData = false;
                loadingElement.remove();
                console.log('NHL player database loaded from server:', playerDatabase);
                const completeMsg = document.createElement('div');
                completeMsg.className = 'stats';
                completeMsg.innerHTML = '‚úÖ Complete NHL player database loaded from server! Ready to play with real data.';
                document.querySelector('.container').insertBefore(completeMsg, document.querySelector('.game-section'));
            } else {
                console.error('Failed to fetch player data from server, falling back to direct API calls.');

            }
            
            // Remove loading indicator
            const loadingEl = document.getElementById('loadingIndicator');
            if (loadingEl) {
                loadingEl.remove();
            }
            
            isLoadingData = false;
            console.log('NHL player database loaded:', playerDatabase);
            
            // Show completion message
            const completeMsg = document.createElement('div');
            completeMsg.className = 'stats';
            completeMsg.innerHTML = '‚úÖ Complete NHL player database loaded! Ready to play with real data.';
            document.querySelector('.container').insertBefore(completeMsg, document.querySelector('.game-section'));
            setTimeout(() => completeMsg.remove(), 3000);
        }

        let selectedTeams = [];
        let addedPlayers = [];
        let gameActive = false;
        let isDailyMode = false;
        let dailyTeamsData = null;
        let userId = null;
        let hasSubmittedDaily = false;

        // Generate or get user ID
        function getUserId() {
            if (!userId) {
                userId = localStorage.getItem('journeyman_user_id');
                if (!userId) {
                    userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('journeyman_user_id', userId);
                }
            }
            return userId;
        }

        // Submit daily solution to backend
        async function submitDailySolution() {
            try {
                console.log('Submitting solution to backend...');
                const response = await fetch('https://journeyman.edgecompute.app/submit_daily', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_id: getUserId(),
                        date: dailyTeamsData.date,
                        players: addedPlayers,
                        player_count: addedPlayers.length
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Daily solution submitted successfully:', result);
                } else {
                    console.error('Failed to submit daily solution:', response.status);
                }
            } catch (error) {
                console.error('Error submitting daily solution:', error);
            }
        }

        function generateNewGame() {
            const allTeams = Object.keys(teamCodes);
            selectedTeams = [];
            
            // Select 8 random teams
            while (selectedTeams.length < 8) {
                const randomTeam = allTeams[Math.floor(Math.random() * allTeams.length)];
                if (!selectedTeams.includes(randomTeam)) {
                    selectedTeams.push(randomTeam);
                }
            }
            
            addedPlayers = [];
            gameActive = true;
            isDailyMode = false;
            dailyTeamsData = null;
            
            // Update game mode display
            document.getElementById('gameMode').textContent = 'Practice Mode';
            document.getElementById('rarityScore').style.display = 'none';
            
            // Re-enable input controls
            const playerInput = document.getElementById('playerInput');
            const addButton = document.querySelector('.input-group button');
            playerInput.disabled = false;
            addButton.disabled = false;
            playerInput.placeholder = "Enter player name...";
            
            updateDisplay();
            document.getElementById('victoryMessage').style.display = 'none';
            document.getElementById('optimalSolutionBtn').style.display = 'none';
        }

        async function startDailyMode() {
            try {
                const response = await fetch('https://journeyman.edgecompute.app/get_daily_teams');
                if (response.ok) {
                    dailyTeamsData = await response.json();
                    selectedTeams = dailyTeamsData.teams;
                    addedPlayers = [];
                    gameActive = true;
                    isDailyMode = true;
                    hasSubmittedDaily = false;
                    
                    // Check if user has already submitted today
                    const submissionCheck = localStorage.getItem(`daily_submitted_${dailyTeamsData.date}`);
                    if (submissionCheck) {
                        hasSubmittedDaily = true;
                        showError('You have already submitted a solution for today! You can view but not resubmit.');
                    }
                    
                    // Update game mode display
                    document.getElementById('gameMode').textContent = `Daily Challenge (${dailyTeamsData.date})`;
                    document.getElementById('rarityScore').style.display = 'none';
                    
                    // Re-enable input controls (unless already submitted)
                    const playerInput = document.getElementById('playerInput');
                    const addButton = document.querySelector('.input-group button');
                    if (!hasSubmittedDaily) {
                        playerInput.disabled = false;
                        addButton.disabled = false;
                        playerInput.placeholder = "Enter player name...";
                    } else {
                        playerInput.disabled = true;
                        addButton.disabled = true;
                        playerInput.placeholder = "Already submitted for today";
                    }
                    
                    updateDisplay();
                    document.getElementById('victoryMessage').style.display = 'none';
                    document.getElementById('optimalSolutionBtn').style.display = 'none';
                } else {
                    showError('Failed to load daily challenge');
                }
            } catch (error) {
                showError('Failed to load daily challenge');
                console.error('Daily mode error:', error);
            }
        }

        function clearPlayers() {
            addedPlayers = [];
            
            // Re-enable input controls
            const playerInput = document.getElementById('playerInput');
            const addButton = document.querySelector('.input-group button');
            playerInput.disabled = false;
            addButton.disabled = false;
            playerInput.placeholder = "Enter player name...";
            
            updateDisplay();
            document.getElementById('victoryMessage').style.display = 'none';
            document.getElementById('optimalSolutionBtn').style.display = 'none';
            
            // Update rarity score if in daily mode
            if (isDailyMode) {
                updateRarityScore();
            }
        }

        function addPlayer() {
            const input = document.getElementById('playerInput');
            const playerName = input.value.trim();
            const errorDiv = document.getElementById('errorMessage');
            const validationDiv = document.getElementById('validationInfo');
            
            if (!playerName) {
                showError("Please enter a player name");
                return;
            }
            
            if (!gameActive) {
                showError("Please start a new game first");
                return;
            }
            
            // Check if already submitted in daily mode
            if (isDailyMode && hasSubmittedDaily) {
                showError("You have already submitted your solution for today");
                return;
            }
            
            if (addedPlayers.some(p => p.toLowerCase() === playerName.toLowerCase())) {
                showError("Player already added");
                return;
            }
            
            // Hide previous messages
            errorDiv.style.display = 'none';
            validationDiv.style.display = 'none';
            
            // Validate and find matching players
            const validationResult = validatePlayerName(playerName);
            
            if (validationResult.status === 'not_found') {
                showError("Player not found in database or didn't play for any selected teams");
                return;
            }
            
            if (validationResult.status === 'no_team_match') {
                showError(`${validationResult.exactMatch} didn't play for any of the selected teams`);
                return;
            }
            
            if (validationResult.status === 'multiple_matches') {
                showDisambiguationModal(validationResult.matches);
                return;
            }
            
            if (validationResult.status === 'valid') {
                // Add the validated player name
                addedPlayers.push(validationResult.playerName);
                input.value = '';
                
                // Show validation info
                const teamsPlayed = validationResult.teamsPlayed;
                validationDiv.innerHTML = `‚úÖ Added ${validationResult.playerName} (played for: ${teamsPlayed.join(', ')})`;
                validationDiv.style.display = 'block';
                setTimeout(() => validationDiv.style.display = 'none', 3000);
                
                updateDisplay();
                checkVictory();
                
                // Calculate rarity score if in daily mode
                if (isDailyMode) {
                    updateRarityScore();
                }
            }
        }

        function validatePlayerName(inputName) {
            if (Object.keys(playerDatabase).length === 0) {
                return { status: 'not_found' };
            }
            
            const normalizedInput = inputName.toLowerCase().trim();
            const allMatches = [];
            
            // Search through all teams in the database
            for (const [teamCode, players] of Object.entries(playerDatabase.teams || {})) {
                const teamName = Object.keys(teamCodes).find(name => teamCodes[name] === teamCode);
                
                players.forEach(player => {
                    const playerName = getPlayerName(player);
                    const normalizedPlayer = playerName.toLowerCase();
                    
                    // Exact match
                    if (normalizedPlayer === normalizedInput) {
                        allMatches.push({
                            name: playerName,
                            teamCode,
                            teamName,
                            matchType: 'exact'
                        });
                    }
                    // Partial match (contains)
                    else if (normalizedPlayer.includes(normalizedInput) || normalizedInput.includes(normalizedPlayer)) {
                        // Avoid very short partial matches
                        if (normalizedInput.length >= 3 && normalizedPlayer.length >= 3) {
                            allMatches.push({
                                name: playerName,
                                teamCode,
                                teamName,
                                matchType: 'partial'
                            });
                        }
                    }
                });
            }
            
            if (allMatches.length === 0) {
                return { status: 'not_found' };
            }
            
            // Group matches by player name
            const uniquePlayers = new Map();
            allMatches.forEach(match => {
                if (!uniquePlayers.has(match.name)) {
                    uniquePlayers.set(match.name, {
                        name: match.name,
                        teams: [],
                        teamsInGame: []
                    });
                }
                
                const player = uniquePlayers.get(match.name);
                if (!player.teams.includes(match.teamName)) {
                    player.teams.push(match.teamName);
                }
                
                // Check if this team is in the current game
                if (selectedTeams.includes(match.teamName)) {
                    if (!player.teamsInGame.includes(match.teamName)) {
                        player.teamsInGame.push(match.teamName);
                    }
                }
            });
            
            // Filter to only players who played for selected teams
            const validPlayers = Array.from(uniquePlayers.values()).filter(player => 
                player.teamsInGame.length > 0
            );
            
            if (validPlayers.length === 0) {
                // Check if we found an exact match but they didn't play for selected teams
                const exactMatches = Array.from(uniquePlayers.values()).filter(player =>
                    player.name.toLowerCase() === normalizedInput
                );
                
                if (exactMatches.length > 0) {
                    return { 
                        status: 'no_team_match', 
                        exactMatch: exactMatches[0].name 
                    };
                }
                
                return { status: 'not_found' };
            }
            
            if (validPlayers.length === 1) {
                return {
                    status: 'valid',
                    playerName: validPlayers[0].name,
                    teamsPlayed: validPlayers[0].teamsInGame
                };
            }
            
            // Multiple valid players found
            return {
                status: 'multiple_matches',
                matches: validPlayers.map(player => ({
                    name: player.name,
                    teamsInGame: player.teamsInGame,
                    allTeams: player.teams
                }))
            };
        }

        function showDisambiguationModal(matches) {
            const modal = document.getElementById('disambiguationModal');
            const optionsDiv = document.getElementById('playerOptions');
            
            optionsDiv.innerHTML = '';
            
            matches.forEach(match => {
                const button = document.createElement('button');
                button.className = 'player-option';
                button.innerHTML = `<div>${match.name}</div>`;
                button.onclick = () => selectDisambiguatedPlayer(match.name, match.teamsInGame);
                optionsDiv.appendChild(button);
            });
            
            modal.style.display = 'flex';
        }

        function selectDisambiguatedPlayer(playerName, teamsPlayed) {
            closeDisambiguationModal();
            
            // Add the selected player
            addedPlayers.push(playerName);
            document.getElementById('playerInput').value = '';
            
            // Show validation info
            const validationDiv = document.getElementById('validationInfo');
            validationDiv.innerHTML = `‚úÖ Added ${playerName} (played for: ${teamsPlayed.join(', ')})`;
            validationDiv.style.display = 'block';
            setTimeout(() => validationDiv.style.display = 'none', 3000);
            
            updateDisplay();
            checkVictory();
            
            // Calculate rarity score if in daily mode
            if (isDailyMode) {
                updateRarityScore();
            }
        }

        function closeDisambiguationModal() {
            document.getElementById('disambiguationModal').style.display = 'none';
        }

        function removePlayer(playerName) {
            addedPlayers = addedPlayers.filter(p => p !== playerName);
            updateDisplay();
            document.getElementById('victoryMessage').style.display = 'none';
            document.getElementById('optimalSolutionBtn').style.display = 'none';
            
            // Update rarity score if in daily mode
            if (isDailyMode) {
                updateRarityScore();
            }
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                addPlayer();
            }
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 3000);
        }

        function updateDisplay() {
            updateTeamsGrid();
            updatePlayersList();
            updateStats();
        }

        function updateTeamsGrid() {
            const grid = document.getElementById('teamsGrid');
            grid.innerHTML = '';
            
            selectedTeams.forEach(team => {
                const teamCard = document.createElement('div');
                teamCard.className = 'team-card';
                
                // Check which players satisfy this team
                const satisfyingPlayers = addedPlayers.filter(player => {
                    const teamid = teamCodes[team];
                    if (Object.keys(playerDatabase).length > 0 && playerDatabase.teams[teamid]) {
                        const teamPlayerNames = getTeamPlayerNames(playerDatabase.teams[teamid]);
                        return teamPlayerNames.some(teamPlayer =>
                            teamPlayer.toLowerCase() === player.toLowerCase()
                        );
                    }
                    return false;
                });
                
                if (satisfyingPlayers.length > 0) {
                    teamCard.classList.add('satisfied');
                }
                
                teamCard.innerHTML = `
                    <div class="team-name">${team}</div>
                    <div class="team-players">${satisfyingPlayers.join(', ') || 'No players yet'}</div>
                `;
                
                grid.appendChild(teamCard);
            });
        }

        function updatePlayersList() {
            const list = document.getElementById('playersList');
            list.innerHTML = '';
            
            addedPlayers.forEach(player => {
                const playerTag = document.createElement('div');
                playerTag.className = 'player-tag';
                playerTag.innerHTML = `
                    ${player}
                    <button class="remove-player" onclick="removePlayer('${player}')">√ó</button>
                `;
                list.appendChild(playerTag);
            });
        }

        function updateStats() {
            const satisfiedTeams = selectedTeams.filter(team => {
                const teamid = teamCodes[team];
                if (Object.keys(playerDatabase).length > 0 && playerDatabase.teams[teamid]) {
                    const teamPlayerNames = getTeamPlayerNames(playerDatabase.teams[teamid]);
                    return addedPlayers.some(player =>
                        teamPlayerNames.some(teamPlayer =>
                            teamPlayer.toLowerCase() === player.toLowerCase()
                        )
                    );
                }
                return false;
            });
            
            document.getElementById('satisfiedCount').textContent = satisfiedTeams.length;
            document.getElementById('playerCount').textContent = addedPlayers.length;
        }

        function checkVictory() {
            const satisfiedTeams = selectedTeams.filter(team => {
                const teamid = teamCodes[team];
                if (Object.keys(playerDatabase).length > 0 && playerDatabase.teams[teamid]) {
                    const teamPlayerNames = getTeamPlayerNames(playerDatabase.teams[teamid]);
                    return addedPlayers.some(player =>
                        teamPlayerNames.some(teamPlayer =>
                            teamPlayer.toLowerCase() === player.toLowerCase()
                        )
                    );
                }
                return false;
            });
            
            console.log(`CheckVictory: ${satisfiedTeams.length}/8 teams satisfied`, satisfiedTeams);
            console.log(`Is daily mode: ${isDailyMode}`);
            
            if (satisfiedTeams.length === 8) {
                console.log('Victory condition met!');
                const optimalSolution = findOptimalSolution();
                const isOptimal = addedPlayers.length === optimalSolution.players.length;
                const victoryDiv = document.getElementById('victoryMessage');
                const optimalBtn = document.getElementById('optimalSolutionBtn');
                const playerInput = document.getElementById('playerInput');
                const addButton = document.querySelector('.input-group button');
                
                console.log('Victory elements found:', {
                    victoryDiv: !!victoryDiv,
                    optimalBtn: !!optimalBtn,
                    playerInput: !!playerInput,
                    addButton: !!addButton
                });
                
                // Handle daily mode submission if not already submitted
                if (isDailyMode && !hasSubmittedDaily) {
                    console.log('Submitting daily solution...');
                    submitDailySolution();
                    hasSubmittedDaily = true;
                    localStorage.setItem(`daily_submitted_${dailyTeamsData.date}`, 'true');
                }
                
                // Show the optimal solution button
                optimalBtn.style.display = 'inline-block';
                
                // Disable input and add button
                playerInput.disabled = true;
                addButton.disabled = true;
                playerInput.placeholder = isDailyMode && hasSubmittedDaily ? 
                    "Solution submitted!" : "Game completed! Start a new game to play again.";
                
                if (isOptimal) {
                    if (isDailyMode) {
                        victoryDiv.innerHTML = `üéâ PERFECT! You found the optimal solution with ${addedPlayers.length} player${addedPlayers.length === 1 ? '' : 's'}! üèÜ<br>
                            <small>Daily Challenge completed with maximum efficiency!</small>`;
                    } else {
                        victoryDiv.innerHTML = `üéâ PERFECT! You found the optimal solution with ${addedPlayers.length} player${addedPlayers.length === 1 ? '' : 's'}! üèÜ`;
                    }
                } else {
                    if (isDailyMode) {
                        victoryDiv.innerHTML = `üéâ Congratulations! Daily Challenge completed with ${addedPlayers.length} player${addedPlayers.length === 1 ? '' : 's'}!<br>
                            <small>üí° Optimal solution uses ${optimalSolution.players.length} player${optimalSolution.players.length === 1 ? '' : 's'}</small>`;
                    } else {
                        victoryDiv.innerHTML = `üéâ Congratulations! You solved it with ${addedPlayers.length} player${addedPlayers.length === 1 ? '' : 's'}!<br>
                            <small>üí° Optimal solution uses ${optimalSolution.players.length} player${optimalSolution.players.length === 1 ? '' : 's'}</small>`;
                    }
                }
                console.log('Setting victory message:', victoryDiv.innerHTML);
                victoryDiv.style.display = 'block';
                console.log('Victory message display set to block');
            }
        }

        // Find the optimal solution using a greedy algorithm with optimization
        function findOptimalSolution() {
            if (Object.keys(playerDatabase.teams).length === 0) {
                return { players: [], teamsCovered: 0 };
            }

            // Build player-to-teams mapping for selected teams only
            const playerTeamsMap = new Map();
            
            selectedTeams.forEach(team => {
                const teamid = teamCodes[team];
                if (playerDatabase.teams[teamid]) {
                    const teamPlayerNames = getTeamPlayerNames(playerDatabase.teams[teamid]);
                    teamPlayerNames.forEach(playerName => {
                        if (!playerTeamsMap.has(playerName)) {
                            playerTeamsMap.set(playerName, new Set());
                        }
                        playerTeamsMap.get(playerName).add(team);
                    });
                }
            });

            // Convert to array for easier processing
            const playersWithTeams = Array.from(playerTeamsMap.entries()).map(([player, teams]) => ({
                name: player,
                teams: Array.from(teams),
                teamCount: teams.size
            }));

            // Try greedy algorithm with different starting strategies
            const solutions = [
                greedySetCover(playersWithTeams, 'most_teams'),
                greedySetCover(playersWithTeams, 'best_coverage'),
                bruteForceBest(playersWithTeams) // For small cases
            ].filter(sol => sol !== null && sol.players.length > 0);

            // Return the best solution found
            if (solutions.length === 0) {
                return { players: [], teamsCovered: 0 };
            }
            
            return solutions.reduce((best, current) => 
                current.players.length < best.players.length ? current : best
            );
        }

        // Greedy set cover algorithm
        function greedySetCover(playersWithTeams, strategy = 'most_teams') {
            const uncoveredTeams = new Set(selectedTeams);
            const selectedPlayers = [];
            const playersCopy = [...playersWithTeams];

            while (uncoveredTeams.size > 0 && playersCopy.length > 0) {
                let bestPlayer = null;
                let bestScore = -1;

                playersCopy.forEach((player, index) => {
                    // Count how many uncovered teams this player covers
                    const newTeamsCovered = player.teams.filter(team => uncoveredTeams.has(team)).length;
                    
                    if (newTeamsCovered === 0) return;

                    let score;
                    if (strategy === 'most_teams') {
                        score = newTeamsCovered;
                    } else { // 'best_coverage'
                        // Prioritize players who cover more teams overall, then new coverage
                        score = newTeamsCovered * 1000 + player.teamCount;
                    }

                    if (score > bestScore) {
                        bestScore = score;
                        bestPlayer = { player, index };
                    }
                });

                if (!bestPlayer) break;

                // Add the best player
                selectedPlayers.push(bestPlayer.player.name);
                bestPlayer.player.teams.forEach(team => uncoveredTeams.delete(team));
                playersCopy.splice(bestPlayer.index, 1);
            }

            return {
                players: selectedPlayers,
                teamsCovered: selectedTeams.length - uncoveredTeams.size
            };
        }

        // Brute force for small cases (when feasible)
        function bruteForceBest(playersWithTeams) {
            // Only attempt brute force for very small sets
            if (playersWithTeams.length > 20 || selectedTeams.length > 6) {
                return null;
            }

            const targetTeams = new Set(selectedTeams);
            let bestSolution = null;

            // Try combinations of increasing size
            for (let size = 1; size <= Math.min(selectedTeams.length, 4); size++) {
                const combinations = generateCombinations(playersWithTeams, size);
                
                for (const combo of combinations) {
                    const coveredTeams = new Set();
                    combo.forEach(player => {
                        player.teams.forEach(team => coveredTeams.add(team));
                    });

                    // Check if this combination covers all teams
                    if (coveredTeams.size === targetTeams.size && 
                        Array.from(targetTeams).every(team => coveredTeams.has(team))) {
                        return {
                            players: combo.map(p => p.name),
                            teamsCovered: coveredTeams.size
                        };
                    }
                }
            }

            return bestSolution;
        }

        // Generate combinations of players
        function generateCombinations(players, size) {
            if (size === 1) {
                return players.map(p => [p]);
            }

            const combinations = [];
            for (let i = 0; i <= players.length - size; i++) {
                const smaller = generateCombinations(players.slice(i + 1), size - 1);
                smaller.forEach(combo => {
                    combinations.push([players[i], ...combo]);
                });
            }
            return combinations;
        }

        // Add a button to show optimal solution
        function showOptimalSolution() {
            const optimal = findOptimalSolution();
            if (optimal.players.length > 0) {
                alert(`Optimal solution (${optimal.players.length} players):\n${optimal.players.join('\n')}`);
            } else {
                alert('Could not calculate optimal solution.');
            }
        }

        // Calculate and display rarity score for daily mode
        async function updateRarityScore() {
            if (!isDailyMode || addedPlayers.length === 0) {
                document.getElementById('rarityScore').style.display = 'none';
                return;
            }

            try {
                const response = await fetch('https://journeyman.edgecompute.app/calculate_rarity', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        players: addedPlayers,
                        date: dailyTeamsData.date
                    })
                });

                if (response.ok) {
                    const rarityData = await response.json();
                    document.getElementById('rarityValue').textContent = rarityData.total_rarity_score.toFixed(2);
                    document.getElementById('rarityScore').style.display = 'block';
                } else {
                    document.getElementById('rarityScore').style.display = 'none';
                }
            } catch (error) {
                console.error('Failed to calculate rarity score:', error);
                document.getElementById('rarityScore').style.display = 'none';
            }
        }

        // Load data and start the game
        async function initializeGame() {
            await loadNHLPlayerData();
            generateNewGame();
        }

        // Start the initialization
        initializeGame();
    </script>
</body>
</html>